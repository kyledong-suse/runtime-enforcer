package v1alpha1

import (
	"errors"
	"slices"

	"github.com/neuvector/runtime-enforcer/internal/types/policymode"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	// PolicyProposalMaxExecutables defines the maximum number of executables that we can learn.
	// This is a arbitrary number right now and can be fine-tuned or made configurable in the future.
	PolicyProposalMaxExecutables = 100
	MaximumSeverity              = 10
	ApprovalLabelKey             = "security.rancher.io/policy-ready"
)

// WorkloadPolicyProposalSpec defines the desired state of WorkloadPolicyProposal.
type WorkloadPolicyProposalSpec struct {
	// selector is a kubernetes label selector used to match
	// workloads using its pod labels.
	// +optional
	Selector *metav1.LabelSelector `json:"selector,omitempty"`

	// rulesByContainer specifies the rules this policy contains, per-container.
	RulesByContainer map[string]*WorkloadSecurityPolicyRules `json:"rulesByContainer,omitempty"`
}

type WorkloadPolicyProposalCondition struct {
	Type   string                 `json:"type"`
	Status corev1.ConditionStatus `json:"status"`
	// lastProbeTime is the time we probed the condition.
	// +optional
	LastProbeTime metav1.Time `json:"lastProbeTime,omitempty"`
	// lastTransitionTime is the time the condition transitioned from one status to another.
	// +optional
	LastTransitionTime metav1.Time `json:"lastTransitionTime,omitempty"`
	// reason is a unique, this should be a short, machine understandable string that gives the reason
	// for condition's last transition. If it reports "ResizeStarted" that means the underlying
	// persistent volume is being resized.
	// +optional
	Reason string `json:"reason,omitempty"`
	// message is the human-readable message indicating details about last transition.
	// +optional
	Message string `json:"message,omitempty"`
}

// WorkloadPolicyProposalStatus defines the observed state of WorkloadPolicyProposal.
type WorkloadPolicyProposalStatus struct {
	Conditions []WorkloadPolicyProposalCondition `json:"conditions,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// WorkloadPolicyProposal is the Schema for the workloadpolicyproposals API.
type WorkloadPolicyProposal struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   WorkloadPolicyProposalSpec   `json:"spec,omitempty"`
	Status WorkloadPolicyProposalStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// WorkloadPolicyProposalList contains a list of WorkloadPolicyProposal.
type WorkloadPolicyProposalList struct {
	metav1.TypeMeta `json:",inline"`

	metav1.ListMeta `json:"metadata,omitempty"`

	Items []WorkloadPolicyProposal `json:"items"`
}

func (p *WorkloadPolicyProposal) getExecutablesLength() int {
	if p.Spec.RulesByContainer == nil {
		return 0
	}

	result := 0
	for _, value := range p.Spec.RulesByContainer {
		result += len(value.Executables.Allowed)
	}

	return result
}

func (p *WorkloadPolicyProposal) AddProcess(containerName string, executable string) error {
	if p.getExecutablesLength() >= PolicyProposalMaxExecutables {
		return errors.New("the number of executables has exceeded its maximum")
	}

	if p.Spec.RulesByContainer == nil {
		p.Spec.RulesByContainer = make(map[string]*WorkloadSecurityPolicyRules)
	}

	rules, ok := p.Spec.RulesByContainer[containerName]
	if !ok {
		p.Spec.RulesByContainer[containerName] = &WorkloadSecurityPolicyRules{
			Executables: WorkloadSecurityPolicyExecutables{
				Allowed: []string{executable},
			},
		}
		return nil
	}

	if slices.Contains(rules.Executables.Allowed, executable) {
		return nil
	}

	rules.Executables.Allowed = append(rules.Executables.Allowed, executable)

	return nil
}

func (p *WorkloadPolicyProposal) AddPartialOwnerReferenceDetails(workloadKind string, workload string) {
	p.OwnerReferences = []metav1.OwnerReference{
		{
			Kind: workloadKind,
			Name: workload,
		},
	}
}

func (p *WorkloadPolicyProposalSpec) IntoWorkloadSecurityPolicySpec() WorkloadSecurityPolicySpec {
	// Setting severity to 10 and enforcement mode to "monitor" by default.
	return WorkloadSecurityPolicySpec{
		Severity:         MaximumSeverity,
		Mode:             policymode.MonitorString,
		Selector:         p.Selector,
		RulesByContainer: p.RulesByContainer,
	}
}

//nolint:gochecknoinits // Generated by kubebuilder
func init() {
	SchemeBuilder.Register(&WorkloadPolicyProposal{}, &WorkloadPolicyProposalList{})
}
