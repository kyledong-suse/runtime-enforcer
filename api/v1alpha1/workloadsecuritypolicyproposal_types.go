package v1alpha1

import (
	"errors"
	"slices"

	"github.com/neuvector/runtime-enforcer/internal/types/policymode"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	// PolicyProposalMaxExecutables defines the maximum number of executables that we can learn.
	// This is a arbitrary number right now and can be fine-tuned or made configurable in the future.
	PolicyProposalMaxExecutables = 100
	MaximumSeverity              = 10
	ApprovalLabelKey             = "security.rancher.io/policy-ready"
)

type WorkloadSecurityPolicyProposalExecutables struct {
	// allowed defines a list of executables that are allowed to run
	// +optional
	Allowed []string `json:"allowed,omitempty"`

	// allowedPrefixes defines a list of prefix with which executables are allowed to run
	// +optional
	AllowedPrefixes []string `json:"allowedPrefixes,omitempty"`
}

// WorkloadSecurityPolicyProposalSpec defines the desired state of WorkloadSecurityPolicyProposal.
type WorkloadSecurityPolicyProposalSpec struct {
	// selector is a kubernetes label selector used to match
	// workloads using its pod labels.
	// +optional
	Selector *metav1.LabelSelector `json:"selector,omitempty"`

	// rules specifies the rules this policy contains
	Rules WorkloadSecurityPolicyRules `json:"rules,omitempty"`
}

type WorkloadSecurityPolicyProposalCondition struct {
	Type   string                 `json:"type"`
	Status corev1.ConditionStatus `json:"status"`
	// lastProbeTime is the time we probed the condition.
	// +optional
	LastProbeTime metav1.Time `json:"lastProbeTime,omitempty"`
	// lastTransitionTime is the time the condition transitioned from one status to another.
	// +optional
	LastTransitionTime metav1.Time `json:"lastTransitionTime,omitempty"`
	// reason is a unique, this should be a short, machine understandable string that gives the reason
	// for condition's last transition. If it reports "ResizeStarted" that means the underlying
	// persistent volume is being resized.
	// +optional
	Reason string `json:"reason,omitempty"`
	// message is the human-readable message indicating details about last transition.
	// +optional
	Message string `json:"message,omitempty"`
}

// WorkloadSecurityPolicyProposalStatus defines the observed state of WorkloadSecurityPolicyProposal.
type WorkloadSecurityPolicyProposalStatus struct {
	Conditions []WorkloadSecurityPolicyProposalCondition `json:"conditions,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// WorkloadSecurityPolicyProposal is the Schema for the workloadsecuritypolicyproposals API.
type WorkloadSecurityPolicyProposal struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   WorkloadSecurityPolicyProposalSpec   `json:"spec,omitempty"`
	Status WorkloadSecurityPolicyProposalStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// WorkloadSecurityPolicyProposalList contains a list of WorkloadSecurityPolicyProposal.
type WorkloadSecurityPolicyProposalList struct {
	metav1.TypeMeta `json:",inline"`

	metav1.ListMeta `json:"metadata,omitempty"`

	Items []WorkloadSecurityPolicyProposal `json:"items"`
}

func (p *WorkloadSecurityPolicyProposal) AddProcess(executable string) error {
	if len(p.Spec.Rules.Executables.Allowed) >= PolicyProposalMaxExecutables {
		return errors.New("the number of executables has exceeded its maximum")
	}
	if slices.Contains(p.Spec.Rules.Executables.Allowed, executable) {
		return nil
	}

	p.Spec.Rules.Executables.Allowed = append(p.Spec.Rules.Executables.Allowed, executable)

	return nil
}

func (p *WorkloadSecurityPolicyProposal) AddPartialOwnerReferenceDetails(workloadKind string, workload string) {
	p.OwnerReferences = []metav1.OwnerReference{
		{
			Kind: workloadKind,
			Name: workload,
		},
	}
}

func (p *WorkloadSecurityPolicyProposalSpec) IntoWorkloadSecurityPolicySpec() WorkloadSecurityPolicySpec {
	// Setting severity to 10 and enforcement mode to "monitor" by default.
	return WorkloadSecurityPolicySpec{
		Rules:    p.Rules,
		Severity: MaximumSeverity,
		Mode:     policymode.MonitorString,
		Selector: p.Selector,
	}
}

//nolint:gochecknoinits // Generated by kubebuilder
func init() {
	SchemeBuilder.Register(&WorkloadSecurityPolicyProposal{}, &WorkloadSecurityPolicyProposalList{})
}
